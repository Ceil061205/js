<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <button>1</button>
  <button>2</button>
  <button>3</button>
  <script>
    // var msg = "Hello, world!";
    // var age = 25;
    // let address = "123 Main St.";
    // {
    //   var msg1 = "Goodbye, world!";
    //   let title = "Developer";
    //   let info = "I am a "
    // }

    const btnEls = document.querySelectorAll("button");
    // 第三种解决方法，用let声明变量i，而不是var。因为在for循环中，每次迭代都会创建一个新的作用域。如果使用var声明变量i，那么所有的事件监听器都将共享同一个i变量的引用，导致所有按钮点击时都输出最后一个迭代的值（即数组长度）。而使用let
    // 如果使用var，则会输出最后一个按钮的索引值
    for (let i = 0; i < btnEls.length; i++) {
      var btnEl = btnEls[i];
      // btnEl.index = i;//第一种解决方法，给每个按钮添加一个index属性来记录其索引值
      btnEl.addEventListener("click", function() {
        // console.log(`点击了第${this.index}个按钮`);
        console.log(`点击了第${i + 1}个按钮`);
      });

      //第二种解决方法，使用闭包
      // (function (m) {
      //   btnEl.addEventListener("click", function() {
      //     console.log(`点击了第${m + 1}个按钮`);
      //   });
      // })(i);
    }


    
/**
 * 
 * 要理解「用`var`定义`i`不行」的核心原因，需要先搞清楚 **`var`的变量提升/函数作用域特性**、**循环执行机制** 和 **事件回调的异步性** 三者的叠加效应。

### 先看关键结论
你的代码中如果把`for (let i = 0;...)`改成`for (var i = 0;...)`，点击按钮时控制台会打印**所有按钮都显示“点击了第N+1个按钮”（N是按钮总数）**，而非预期的第1、2、3个。

### 分步拆解原因

#### 1. `var` vs `let` 的作用域本质差异
| 特性                | var（函数作用域）| let（块级作用域）|
|---------------------|---------------------------------|---------------------------------|
| 作用域范围          | 整个函数/全局（而非循环块）| 仅当前循环迭代的块（每次循环新建） |
| 变量提升            | 提升到函数顶部（存在“变量提升”） | 暂时性死区（无提升，块内才可用） |
| 循环中是否复用变量  | 复用同一个变量（全局/函数级i）| 每次循环创建新的i（独立副本）|

#### 2. 循环执行 + 事件回调的异步性
- 循环是**同步执行**的：循环会快速执行完所有迭代，此时`i`的值会最终变成`btnEls.length`（比如3个按钮，i最终是3）。
- 点击事件是**异步触发**的：当你点击按钮时，循环早已结束，此时去访问`i`，拿到的是循环结束后的最终值（而非点击按钮对应的迭代值）。

#### 3. 用`var`的具体问题演示（假设3个按钮）
```javascript
// 错误示例：var定义i
for (var i = 0; i < 3; i++) { // i是全局/函数级变量，全程复用
  btnEls[i].addEventListener("click", function() {
    console.log(`点击了第${i + 1}个按钮`); // 点击时i已经是3 → 打印“第4个”
  });
}
// 循环结束后，i的值固定为3（因为i < 3不成立时停止，最后一次i++后i=3）
```
- 循环过程：i从0→1→2→3（循环结束），全程只有**一个i变量**。
- 点击按钮时：回调函数访问的是这个唯一的i，此时i=3 → 所有按钮都打印“第4个”。

#### 4. 用`let`的解决原理
```javascript
// 正确示例：let定义i
for (let i = 0; i < 3; i++) { // 每次循环创建新的i（块级作用域）
  btnEls[i].addEventListener("click", function() {
    console.log(`点击了第${i + 1}个按钮`); // 访问的是当前迭代的i副本
  });
}
```
- `let`在循环中**每次迭代都会创建一个新的i变量**（独立作用域），回调函数会捕获当前迭代的i副本。
- 点击第1个按钮 → 捕获的是i=0的副本；点击第2个 → 捕获i=1的副本，以此类推。

### 你代码中两种解决方案的本质
你注释里的两种方法，核心都是**打破“共享同一个i变量”的问题**：
1. **给按钮加index属性**：把当前迭代的i值“存”在按钮元素上，点击时取元素自身的index（而非共享的i）。
2. **闭包（立即执行函数IIFE）**：通过IIFE创建独立作用域，把当前i值作为参数m传入，回调捕获的是每个作用域的m（而非共享的i）。

### 总结
- `var`不行的核心：**函数作用域导致循环全程复用同一个i，异步回调访问时i已变成最终值**。
- `let`可行的核心：**块级作用域导致每次循环创建新的i，回调捕获的是对应迭代的i副本**。
- 其他方案（属性/闭包）：本质都是“为每个回调绑定独立的迭代值”，避开共享变量的坑。
*/
  </script>
</body>
</html>